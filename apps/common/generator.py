from typing import Listfrom bot import loggerfrom utils.translate import translateMessagefrom utils import textfrom bs4 import BeautifulSoupfrom apps.core.managers import ChatActivityManager, ChatManagerfrom apps.subscription.managers import FreeApiKeyManager, ConfigurationManagerfrom apps.common.settings import settingsfrom apps.common.exception import AiogramException, InvalidRequestExceptionimport jsonimport aiohttpimport randomclass ImageGenerator:    url = "https://deepdreamgenerator.com/search-text"    @classmethod    def parse(cls, src: str):        soup = BeautifulSoup(src, "lxml")        images = soup.find_all("img", class_="lazyload")        return [image.get("data-src") for image in images]    @classmethod    async def generate(cls, userId: int, prompt: str):        translatedPrompt = translateMessage(prompt, from_='auto', to='en', isTranslate=True).strip()        body = {"q": translatedPrompt, "offset": 0}        try:            async with aiohttp.ClientSession() as session:                async with session.post(url=cls.url, json=body) as resp:                    htmlResponse = (await resp.json())["results"]                    images = cls.parse(htmlResponse)        except aiohttp.client.ClientResponseError as e:            logger.exception("An error occured", exc_info=e.message)            raise InvalidRequestException(chatId=userId, messageText=text.IMAGE_GEN_NOT_AVAILABLE)        random.shuffle(images)        return images[:6]class ResponseHandler:    def __init__(self, response: dict, chatId: int, apiKey: str):        self.response = response        self.chatId = chatId        self.apiKey = apiKey    async def handleError(self):        error = self.response.get("error")        errorMessage = error.get('message')        logger.error(errorMessage)        raise InvalidRequestException(chatId=self.chatId, messageText=errorMessage,                                      apikey=self.apiKey)    async def getMessage(self) -> str:        error = self.response.get('error')        if error:            return await self.handleError()        content = self.response.get('choices')[0]['message']['content']        await self.updateChatActivity()        return content    async def updateChatActivity(self):        """Update chat activity and token counts based on the response."""        ChatActivityManager.incrementActivityCount(chatId=self.chatId, column="allMessages")class GPTRequest:    URL = "https://api.openai.com/v1/chat/completions"    def __init__(self, chatId: int, isPremium: bool):        self.chatId = chatId        self.isPremium = isPremium        self.config = ConfigurationManager.getConfigs()        self.apiKey = self._initialize_api_key()        self.frequency_penalty = 1.5 if isPremium else 1    def _initialize_api_key(self) -> str:        """Initializes and cycles to the next API key."""        ChatManager.updateChatLastVisit(chatId=self.chatId)        if self.isPremium:            return settings.API_KEY        totalKeys = FreeApiKeyManager.getTotalActiveKeysCount()        currentPosition = self.config.apikeyPosition        nextPosition = (currentPosition + 1) % totalKeys        ConfigurationManager.updatePosition(nextPosition)        freeApiKeyObj = FreeApiKeyManager.getApiKey(nextPosition)        FreeApiKeyManager.incrementRequest(apiKeyId=freeApiKeyObj.id)        return freeApiKeyObj.apiKey    async def generate(self, messages: List[dict]):        """Generate responses from GPT-3.5 based on provided messages."""        headers = {"Authorization": f"Bearer {self.apiKey}"}        requestPayload = {            "model": "gpt-3.5-turbo-0125",            "messages": messages,            "max_tokens": 300,            "frequency_penalty": self.frequency_penalty        }        async with aiohttp.ClientSession(cookie_jar=aiohttp.CookieJar(unsafe=True)) as session:            async with session.post(self.URL, headers=headers,                                    json=requestPayload) as response:                responseData = await response.read()            responseData = json.loads(responseData)            return await ResponseHandler(response=responseData, chatId=self.chatId,                                         apiKey=self.apiKey).getMessage()