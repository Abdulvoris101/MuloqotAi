from datetime import datetimefrom enum import Enumfrom typing import Optional, List, Anyfrom pydantic import BaseModel, Field, validator, field_validatorclass ChatType(Enum):    PRIVATE = "private"    SUPERGROUP = "supergroup"    GROUP = "group"class ChatGptRole(Enum):    USER = "user"    SYSTEM = "system"    ASSISTANT = "assistant"class MessageType(Enum):    MESSAGE = "message"    IMAGE = "image"class ChatActivityBase(BaseModel):    chatId: int    allMessages: int = 0    translatedMessagesCount: int = 0class ChatActivityScheme(ChatActivityBase):    id: int    class Config:        from_attributes = Trueclass ChatActivityCreateScheme(BaseModel):    chatId: intclass ChatActivityViewScheme(ChatActivityBase):    currentMonthMessages: int = 0    currentMonthImages: int = 0    availableGptRequests: int = 0    availableImageRequests: int = 0class ChatBase(BaseModel):    chatId: int = Field(alias='id')    chatName: str = Field(alias='full_name')    chatType: ChatType = Field(alias='type')    username: Optional[str]    createdAt: datetime = datetime.now()    lastUpdated: datetime = datetime.now()    @field_validator('chatType')    def convert_chat_type(cls, v):        if isinstance(v, str):            return ChatType(v.lower())        return vclass ChatScheme(ChatBase):    id: int    chatActivity: List[ChatActivityScheme] = []    class Config:        populate_by_name = True  # Use this to control behavior globallyclass ChatCreateScheme(ChatBase):    passclass MessageBase(BaseModel):    content: str    role: Optional[ChatGptRole] = None    uzMessage: Optional[str] = None    messageType: Optional[MessageType] = None    chat: ChatBase    tokensCount: int    isCleaned: Optional[bool]    createdAt: datetime = datetime.now()class MessageScheme(MessageBase):    id: intclass MessageCreateScheme(MessageBase):    isCleaned: Optional[bool] = False