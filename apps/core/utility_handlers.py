import asynciofrom aiogram.exceptions import DetailedAiogramErrorfrom bot import bot, loggerfrom utils import text, countTokenOfMessagefrom utils.message import fixMessageMarkdownfrom .managers import MessageManagerfrom .models import ChatActivity, Chatfrom apps.common.exception import ForbiddenExceptionfrom utils.translate import translateMessage, getMessageIsTranslate, skipCodeTranslationfrom aiogram import typesfrom .keyboards import feedbackMarkup, messageMarkupfrom ..common.generator import ImageGenerator, GPTRequestfrom ..common.settings import settingsfrom ..subscription.managers import ConfigurationManager, SubscriptionManager, LimitManager, PlanManagerfrom ..subscription.models import Limit, Planclass BaseMessageHandler:    def __init__(self, message: types.Message):        self.message = message        self.chat = message.chat        self.isTranslate = getMessageIsTranslate(message.text)        self.markup = messageMarkup if self.chat.type == "private" and not self.isTranslate else None        self.isPremiumToken = SubscriptionManager.isPremiumToken(self.chat.id)        planId = SubscriptionManager.getChatCurrentSubscription(self.chat.id).planId        self.plan = PlanManager.get(planId=planId)        self.limit = Limit.get(self.plan.limitId)    async def _request_feedback(self):        if ConfigurationManager.getConfigs().isBeta and ChatActivity.get(self.chat.id).allMessages == 10:            return await bot.send_message(self.chat.id, text.REQUEST_FEEDBACK_MESSAGE,                                          reply_markup=feedbackMarkup)    async def checkTokenLimit(self):        if countTokenOfMessage(self.message.text) >= 300:            raise ForbiddenException(chatId=self.chat.id, messageText=text.TOKEN_REACHED)    async def checkPermissions(self, messageType: str, model: str):        subscription = SubscriptionManager.getChatCurrentSubscription(self.chat.id)        if LimitManager.hasQuotaExceeded(self.chat.id, messageType=messageType, model=model):            if self.chat.type in settings.AVAILABLE_GROUP_TYPES:                raise ForbiddenException(chatId=self.chat.id, messageText=text.LIMIT_GROUP_REACHED)            userUsedRequests = LimitManager.getUsedRequests(chatId=self.chat.id,                                                            messageType=messageType, model=model,                                                            subscription=subscription)            raise ForbiddenException(chatId=self.chat.id,                                     messageText=text.getLimitReached(userUsedRequests,                                                                      self.isPremiumToken))    async def sendMessageResponse(self, messageText: str, *args, **kwargs) -> None:        """Sends a message to the user, handling private and group chats differently."""        if self.chat.type == "private":            await self.message.answer(messageText, *args, **kwargs)        else:            await self.message.reply(messageText, *args, **kwargs)class ImageMessageHandler(BaseMessageHandler):    def __init__(self, message: types.Message):        self.model = 'lexica'        super().__init__(message)    async def handle(self):        await self.checkPermissions(messageType='image', model=self.model)        if self.chat.id != settings.IMAGE_GEN_GROUP_ID:            raise ForbiddenException(chatId=self.chat.id, messageText=text.UNAVAILABLE_GROUP_TEXT)        images = await ImageGenerator.generate(self.chat.id, self.message.text)        MessageManager.addImage(query=self.message.text, chat=self.message.chat, model=self.model)        media_group = [types.InputMediaPhoto(media=url) for url in images]        media_group[0].caption = text.IMAGE_RESPONSE_TEMPLATE.format(caption=self.message.text)        await bot.send_media_group(self.chat.id, media=media_group)class TextMessageHandler(BaseMessageHandler):    def __init__(self, message: types.Message):        super().__init__(message)        chat = Chat.get(self.chat.id)        self.model = chat.currentGptModel        self.userText = translateMessage(self.message.text, to='en', isTranslate=self.isTranslate)    async def handle(self):        await self.checkTokenLimit()        await self.checkPermissions(messageType='message', model=self.model)        MessageManager.addMessage(content=self.userText, uzMessage=self.message.text,                                  chat=self.message.chat, role='user', model=self.model)        messages = MessageManager.getLimitedMessages(chatId=self.chat.id,                                                     maxTokens=self.limit.limitInputTokens)        response = await GPTRequest(chatId=self.chat.id, isPremium=self.isPremiumToken,                                    limitOutputTokens=self.limit.limitOutputTokens, model=self.model).generate(messages)        uzMessage = skipCodeTranslation(response, self.isTranslate)        MessageManager.addMessage(content=response, uzMessage=uzMessage,                                  chat=self.message.chat, role='assistant', model=self.model)        await self.sendMessageResponse(messageText=fixMessageMarkdown(uzMessage), disable_web_page_preview=True,                                       parse_mode="MARKDOWN", reply_markup=self.markup)        if self.chat.type == "private":            await self._request_feedback()    async def sendStreamingMessage(self, streamingText: str):        messageChunkSize = 18        updateInterval = 0.1        try:            msg = await bot.send_message(self.chat.id, streamingText[:messageChunkSize])            for i in range(18, len(streamingText), 18):                await asyncio.sleep(updateInterval)                await bot.edit_message_text(chat_id=self.chat.id, message_id=msg.message_id,                                            text=streamingText[:i + 8])        except DetailedAiogramError as e:            logger.exception("An error occured", exc_info=e.message)            return self.message.reply(text.SERVER_ERROR_TRY_AGAIN)